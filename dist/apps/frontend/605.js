"use strict";(self.webpackChunkfrontend=self.webpackChunkfrontend||[]).push([[605],{6605:(ct,R,o)=>{o.d(R,{m1:()=>nt,E6:()=>tt,_b:()=>rt});var H=o(5592),T=o(7394),D=o(1954);let v,F=1;const f={};function g(s){return s in f&&(delete f[s],!0)}const K={setImmediate(s){const e=F++;return f[e]=!0,v||(v=Promise.resolve()),v.then(()=>g(e)&&s()),e},clearImmediate(s){g(s)}},{setImmediate:L,clearImmediate:M}=K,p={setImmediate(...s){const{delegate:e}=p;return(e?.setImmediate||L)(...s)},clearImmediate(s){const{delegate:e}=p;return(e?.clearImmediate||M)(s)},delegate:void 0};var Q=o(2631);const $=new class G extends Q.v{flush(e){this._active=!0;const t=this._scheduled;this._scheduled=void 0;const{actions:n}=this;let i;e=e||n.shift();do{if(i=e.execute(e.state,e.delay))break}while((e=n[0])&&e.id===t&&n.shift());if(this._active=!1,i){for(;(e=n[0])&&e.id===t&&n.shift();)e.unsubscribe();throw i}}}(class N extends D.o{constructor(e,t){super(e,t),this.scheduler=e,this.work=t}requestAsyncId(e,t,n=0){return null!==n&&n>0?super.requestAsyncId(e,t,n):(e.actions.push(this),e._scheduled||(e._scheduled=p.setImmediate(e.flush.bind(e,void 0))))}recycleAsyncId(e,t,n=0){var i;if(null!=n?n>0:this.delay>0)return super.recycleAsyncId(e,t,n);const{actions:r}=e;null!=t&&(null===(i=r[r.length-1])||void 0===i?void 0:i.id)!==t&&(p.clearImmediate(t),e._scheduled===t&&(e._scheduled=void 0))}});var m=o(7328),x=o(7258),j=o(2096),A=o(2381),C=o(6232),U=o(8504),W=o(5154),X=o(2572),Y=o(8645),O=o(8180),d=o(9773),Z=o(3093),y=o(9397),w=o(2460),E=o(7398),P=o(6306),J=o(3997),V=o(3020),k=o(4716),l=o(5879),q=o(1993);function S(s){return"function"==typeof s.ngrxOnStoreInit}function b(s){return"function"==typeof s.ngrxOnStateInit}function tt(s){const e=new l.OlP("@ngrx/component-store ComponentStore with Hooks");return[{provide:e,useClass:s},{provide:s,useFactory:()=>{const t=(0,l.f3M)(e);return t.\u0275hasProvider=!0,S(t)&&t.ngrxOnStoreInit(),b(t)&&t.state$.pipe((0,O.q)(1)).subscribe(()=>t.ngrxOnStateInit()),t}}]}const et=new l.OlP("@ngrx/component-store Initial State");let nt=(()=>{class s{constructor(t){this.destroySubject$=new m.t(1),this.destroy$=this.destroySubject$.asObservable(),this.stateSubject$=new m.t(1),this.isInitialized=!1,this.state$=this.select(n=>n),this.state=(0,q.O4)(this.stateSubject$.pipe((0,d.R)(this.destroy$)),{requireSync:!1,manualCleanup:!0}),this.\u0275hasProvider=!1,t&&this.initState(t),this.checkProviderForHooks()}ngOnDestroy(){this.stateSubject$.complete(),this.destroySubject$.next()}updater(t){return n=>{let r,i=!0;const c=((0,x.b)(n)?n:(0,j.of)(n)).pipe((0,Z.Q)(A.N),(0,y.b)(()=>this.assertStateIsInitialized()),(0,w.M)(this.stateSubject$),(0,E.U)(([a,h])=>t(h,a)),(0,y.b)(a=>this.stateSubject$.next(a)),(0,P.K)(a=>i?(r=a,C.E):(0,U._)(a)),(0,d.R)(this.destroy$)).subscribe();if(r)throw r;return i=!1,c}}initState(t){(0,W.x)([t],A.N).subscribe(n=>{this.isInitialized=!0,this.stateSubject$.next(n)})}setState(t){"function"!=typeof t?this.initState(t):this.updater(t)()}patchState(t){const n="function"==typeof t?t(this.get()):t;this.updater((i,r)=>({...i,...r}))(n)}get(t){let n;return this.assertStateIsInitialized(),this.stateSubject$.pipe((0,O.q)(1)).subscribe(i=>{n=t?t(i):i}),n}select(...t){const{observablesOrSelectorsObject:n,projector:i,config:r}=function st(s){const e=Array.from(s);let t={debounce:!1};if(function it(s){return typeof s.debounce<"u"}(e[e.length-1])&&(t={...t,...e.pop()}),1===e.length&&"function"!=typeof e[0])return{observablesOrSelectorsObject:e[0],projector:void 0,config:t};const n=e.pop();return{observablesOrSelectorsObject:e,projector:n,config:t}}(t);return(function ot(s,e){return Array.isArray(s)&&0===s.length&&e}(n,i)?this.stateSubject$:(0,X.a)(n)).pipe(r.debounce?function _(){return s=>new H.y(e=>{let t,n;const i=new T.w0;return i.add(s.subscribe({complete:()=>{t&&e.next(n),e.complete()},error:r=>{e.error(r)},next:r=>{n=r,t||(t=$.schedule(()=>{e.next(n),t=void 0}),i.add(t))}})),i})}():s=>s,i?(0,E.U)(c=>n.length>0&&Array.isArray(c)?i(...c):i(c)):s=>s,(0,J.x)(),function B(s,e,t){let n,i=!1;return s&&"object"==typeof s?({bufferSize:n=1/0,windowTime:e=1/0,refCount:i=!1,scheduler:t}=s):n=s??1/0,(0,V.B)({connector:()=>new m.t(n,e,t),resetOnError:!0,resetOnComplete:!1,resetOnRefCountZero:i})}({refCount:!0,bufferSize:1}),(0,d.R)(this.destroy$))}selectSignal(...t){const n=[...t],i=(h,I)=>h===I,r="object"==typeof n[t.length-1]?{equal:n.pop().equal||i}:{equal:i},u=n.pop(),c=n;return(0,l.Flj)(0===c.length?()=>u(this.state()):()=>{const h=c.map(I=>I());return u(...h)},r)}effect(t){const n=new Y.x;return t(n).pipe((0,d.R)(this.destroy$)).subscribe(),i=>((0,x.b)(i)?i:(0,j.of)(i)).pipe((0,d.R)(this.destroy$)).subscribe(u=>{n.next(u)})}checkProviderForHooks(){$.schedule(()=>{if((0,l.X6Q)()&&(S(this)||b(this))&&!this.\u0275hasProvider){const t=[S(this)?"OnStoreInit":"",b(this)?"OnStateInit":""].filter(n=>n);console.warn(`@ngrx/component-store: ${this.constructor.name} has the ${t.join(" and ")} lifecycle hook(s) implemented without being provided using the provideComponentStore(${this.constructor.name}) function. To resolve this, provide the component store via provideComponentStore(${this.constructor.name})`)}})}assertStateIsInitialized(){if(!this.isInitialized)throw new Error(`${this.constructor.name} has not been initialized yet. Please make sure it is initialized before updating/getting.`)}static#t=this.\u0275fac=function(n){return new(n||s)(l.LFG(et,8))};static#e=this.\u0275prov=l.Yz7({token:s,factory:s.\u0275fac})}return s})();function rt(s,e,t){const n="function"==typeof s?{next:s,error:e,complete:t}:s;return i=>i.pipe((0,y.b)({next:n.next,complete:n.complete}),(0,P.K)(r=>(n.error(r),C.E)),n.finalize?(0,k.x)(n.finalize):r=>r)}}}]);